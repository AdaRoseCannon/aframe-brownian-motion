{"version":3,"file":"aframe-brownian-motion.min.js","sources":["../src/noise.js","../src/aframe-brownian-motion.js"],"sourcesContent":["/* jshint esversion: 9, varstmt:true */\n/*\n * A speed-improved perlin and simplex noise algorithms for 2D.\n *\n * Based on example code by Stefan Gustavson (stegu@itn.liu.se).\n * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\n * Better rank ordering method by Stefan Gustavson in 2012.\n * Converted to Javascript by Joseph Gentle.\n *\n * Version 2012-03-09\n * \n * Modified by AdaRoseCannon 2022-14-07 for AFrame\n *\n * This code was placed in the public domain by its original author,\n * Stefan Gustavson. You may use it as you see fit, but\n * attribution is appreciated.\n *\n */\n\nclass Grad {\n\tconstructor(x, y, z) {\n\t\tthis.x = x; this.y = y; this.z = z;\n\t}\n\tdot2(x, y) {\n\t\treturn this.x * x + this.y * y;\n\t}\n\tdot3(x, y, z) {\n\t\treturn this.x * x + this.y * y + this.z * z;\n\t}\n}\n\nconst grad3 = [new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0),\nnew Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1),\nnew Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1)];\n\nconst p = new Uint8Array([151, 160, 137, 91, 90, 15,\n\t131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,\n\t190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,\n\t88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,\n\t77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,\n\t102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,\n\t135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,\n\t5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,\n\t223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,\n\t129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,\n\t251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,\n\t49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\n\t138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180]);\n// To remove the need for index wrapping, double the permutation table length\nconst perm = new Uint16Array(512);\nconst gradP = Array(512);\n\n// This isn't a very good seeding function, but it works ok. It supports 2^16\n// different seed values. Write something better if you need more seeds.\nexport function seed (seed) {\n\tif (seed > 0 && seed < 1) {\n\t\t// Scale the seed out\n\t\tseed *= 65536;\n\t}\n\n\tseed = Math.floor(seed);\n\tif (seed < 256) {\n\t\tseed |= seed << 8;\n\t}\n\n\tfor (let i = 0; i < 256; i++) {\n\t\tlet v;\n\t\tif (i & 1) {\n\t\t\tv = p[i] ^ (seed & 255);\n\t\t} else {\n\t\t\tv = p[i] ^ ((seed >> 8) & 255);\n\t\t}\n\n\t\tperm[i] = perm[i + 256] = v;\n\t\tgradP[i] = gradP[i + 256] = grad3[v % 12];\n\t}\n}\n\nseed(0);\n\n/*\nfor(const i=0; i<256; i++) {\n\tperm[i] = perm[i + 256] = p[i];\n\tgradP[i] = gradP[i + 256] = grad3[perm[i] % 12];\n}*/\n\n// Skewing and unskewing factors for 2, 3, and 4 dimensions\nconst F2 = 0.5 * (Math.sqrt(3) - 1);\nconst G2 = (3 - Math.sqrt(3)) / 6;\n\nconst F3 = 1 / 3;\nconst G3 = 1 / 6;\n\n// 2D simplex noise\nexport function simplex2 (xin, yin) {\n\tlet n0, n1, n2; // Noise contributions from the three corners\n\t// Skew the input space to determine which simplex cell we're in\n\tconst s = (xin + yin) * F2; // Hairy factor for 2D\n\tlet i = Math.floor(xin + s);\n\tlet j = Math.floor(yin + s);\n\tconst t = (i + j) * G2;\n\tconst x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n\tconst y0 = yin - j + t;\n\t// For the 2D case, the simplex shape is an equilateral triangle.\n\t// Determine which simplex we are in.\n\tlet i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\tif (x0 > y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n\t\ti1 = 1; j1 = 0;\n\t} else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n\t\ti1 = 0; j1 = 1;\n\t}\n\t// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n\t// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n\t// c = (3-sqrt(3))/6\n\tconst x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\tconst y1 = y0 - j1 + G2;\n\tconst x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\n\tconst y2 = y0 - 1 + 2 * G2;\n\t// Work out the hashed gradient indices of the three simplex corners\n\ti &= 255;\n\tj &= 255;\n\tconst gi0 = gradP[i + perm[j]];\n\tconst gi1 = gradP[i + i1 + perm[j + j1]];\n\tconst gi2 = gradP[i + 1 + perm[j + 1]];\n\t// Calculate the contribution from the three corners\n\tlet t0 = 0.5 - x0 * x0 - y0 * y0;\n\tif (t0 < 0) {\n\t\tn0 = 0;\n\t} else {\n\t\tt0 *= t0;\n\t\tn0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient\n\t}\n\tlet t1 = 0.5 - x1 * x1 - y1 * y1;\n\tif (t1 < 0) {\n\t\tn1 = 0;\n\t} else {\n\t\tt1 *= t1;\n\t\tn1 = t1 * t1 * gi1.dot2(x1, y1);\n\t}\n\tlet t2 = 0.5 - x2 * x2 - y2 * y2;\n\tif (t2 < 0) {\n\t\tn2 = 0;\n\t} else {\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * gi2.dot2(x2, y2);\n\t}\n\t// Add contributions from each corner to get the final noise value.\n\t// The result is scaled to return values in the interval [-1,1].\n\treturn 70 * (n0 + n1 + n2);\n}\n\n// 3D simplex noise\nexport function simplex3 (xin, yin, zin) {\n\tlet n0, n1, n2, n3; // Noise contributions from the four corners\n\n\t// Skew the input space to determine which simplex cell we're in\n\tconst s = (xin + yin + zin) * F3; // Hairy factor for 2D\n\tlet i = Math.floor(xin + s);\n\tlet j = Math.floor(yin + s);\n\tlet k = Math.floor(zin + s);\n\n\tconst t = (i + j + k) * G3;\n\tconst x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n\tconst y0 = yin - j + t;\n\tconst z0 = zin - k + t;\n\n\t// For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n\t// Determine which simplex we are in.\n\tlet i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n\tlet i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n\tif (x0 >= y0) {\n\t\tif (y0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }\n\t\telse if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; }\n\t\telse { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; }\n\t} else {\n\t\tif (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; }\n\t\telse if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; }\n\t\telse { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }\n\t}\n\t// A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n\t// a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n\t// a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n\t// c = 1/6.\n\tconst x1 = x0 - i1 + G3; // Offsets for second corner\n\tconst y1 = y0 - j1 + G3;\n\tconst z1 = z0 - k1 + G3;\n\n\tconst x2 = x0 - i2 + 2 * G3; // Offsets for third corner\n\tconst y2 = y0 - j2 + 2 * G3;\n\tconst z2 = z0 - k2 + 2 * G3;\n\n\tconst x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner\n\tconst y3 = y0 - 1 + 3 * G3;\n\tconst z3 = z0 - 1 + 3 * G3;\n\n\t// Work out the hashed gradient indices of the four simplex corners\n\ti &= 255;\n\tj &= 255;\n\tk &= 255;\n\tconst gi0 = gradP[i + perm[j + perm[k]]];\n\tconst gi1 = gradP[i + i1 + perm[j + j1 + perm[k + k1]]];\n\tconst gi2 = gradP[i + i2 + perm[j + j2 + perm[k + k2]]];\n\tconst gi3 = gradP[i + 1 + perm[j + 1 + perm[k + 1]]];\n\n\t// Calculate the contribution from the four corners\n\tlet t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\n\tif (t0 < 0) {\n\t\tn0 = 0;\n\t} else {\n\t\tt0 *= t0;\n\t\tn0 = t0 * t0 * gi0.dot3(x0, y0, z0);  // (x,y) of grad3 used for 2D gradient\n\t}\n\tlet t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\n\tif (t1 < 0) {\n\t\tn1 = 0;\n\t} else {\n\t\tt1 *= t1;\n\t\tn1 = t1 * t1 * gi1.dot3(x1, y1, z1);\n\t}\n\tlet t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\n\tif (t2 < 0) {\n\t\tn2 = 0;\n\t} else {\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * gi2.dot3(x2, y2, z2);\n\t}\n\tlet t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\n\tif (t3 < 0) {\n\t\tn3 = 0;\n\t} else {\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * gi3.dot3(x3, y3, z3);\n\t}\n\t// Add contributions from each corner to get the final noise value.\n\t// The result is scaled to return values in the interval [-1,1].\n\treturn 32 * (n0 + n1 + n2 + n3);\n\n}\n\n// ##### Perlin noise stuff\n\nfunction fade(t) {\n\treturn t * t * t * (t * (t * 6 - 15) + 10);\n}\n\nfunction lerp(a, b, t) {\n\treturn (1 - t) * a + t * b;\n}\n\n// 2D Perlin Noise\nexport function perlin2 (x, y) {\n\t// Find unit grid cell containing point\n\tlet X = Math.floor(x), Y = Math.floor(y);\n\t// Get relative xy coordinates of point within that cell\n\tx = x - X; y = y - Y;\n\t// Wrap the integer cells at 255 (smaller integer period can be introduced here)\n\tX = X & 255; Y = Y & 255;\n\n\t// Calculate noise contributions from each of the four corners\n\tconst n00 = gradP[X + perm[Y]].dot2(x, y);\n\tconst n01 = gradP[X + perm[Y + 1]].dot2(x, y - 1);\n\tconst n10 = gradP[X + 1 + perm[Y]].dot2(x - 1, y);\n\tconst n11 = gradP[X + 1 + perm[Y + 1]].dot2(x - 1, y - 1);\n\n\t// Compute the fade curve value for x\n\tconst u = fade(x);\n\n\t// Interpolate the four results\n\treturn lerp(\n\t\tlerp(n00, n10, u),\n\t\tlerp(n01, n11, u),\n\t\tfade(y));\n}\n\n// 3D Perlin Noise\nexport function perlin3 (x, y, z) {\n\t// Find unit grid cell containing point\n\tlet X = Math.floor(x), Y = Math.floor(y), Z = Math.floor(z);\n\t// Get relative xyz coordinates of point within that cell\n\tx = x - X; y = y - Y; z = z - Z;\n\t// Wrap the integer cells at 255 (smaller integer period can be introduced here)\n\tX = X & 255; Y = Y & 255; Z = Z & 255;\n\n\t// Calculate noise contributions from each of the eight corners\n\tconst n000 = gradP[X + perm[Y + perm[Z]]].dot3(x, y, z);\n\tconst n001 = gradP[X + perm[Y + perm[Z + 1]]].dot3(x, y, z - 1);\n\tconst n010 = gradP[X + perm[Y + 1 + perm[Z]]].dot3(x, y - 1, z);\n\tconst n011 = gradP[X + perm[Y + 1 + perm[Z + 1]]].dot3(x, y - 1, z - 1);\n\tconst n100 = gradP[X + 1 + perm[Y + perm[Z]]].dot3(x - 1, y, z);\n\tconst n101 = gradP[X + 1 + perm[Y + perm[Z + 1]]].dot3(x - 1, y, z - 1);\n\tconst n110 = gradP[X + 1 + perm[Y + 1 + perm[Z]]].dot3(x - 1, y - 1, z);\n\tconst n111 = gradP[X + 1 + perm[Y + 1 + perm[Z + 1]]].dot3(x - 1, y - 1, z - 1);\n\n\t// Compute the fade curve value for x, y, z\n\tconst u = fade(x);\n\tconst v = fade(y);\n\tconst w = fade(z);\n\n\t// Interpolate\n\treturn lerp(\n\t\tlerp(\n\t\t\tlerp(n000, n100, u),\n\t\t\tlerp(n001, n101, u), w),\n\t\tlerp(\n\t\t\tlerp(n010, n110, u),\n\t\t\tlerp(n011, n111, u), w),\n\t\tv);\n}\n","/* jshint esversion: 9, -W028 */\n/* For dealing with covering one object in another curves */\n/* global THREE, AFRAME */\n\nimport {perlin2, seed} from './noise.js';\n\nconst schema = {\n\tspaceVector: {\n\t\ttype: 'array'\n\t},\n\toctaves: {\n\t\tdefault: 2\n\t},\n\tpositionVariance: {\n\t\ttype: 'vec3',\n\t\tdefault: new THREE.Vector3(1,1,1)\n\t},\n\trotationVariance: {\n\t\ttype: 'vec3',\n\t\tdefault: new THREE.Vector3(10,10,10)\n\t},\n\tspeed: {\n\t\tdefault: 1\n\t},\n\trotationFollowsAxis: {\n\t\toneOf: ['x', 'y', 'z', '-x', '-y', '-z',, 'none'],\n\t\tdefault: 'none'\n\t}\n};\n\ndocumentation:\n(function () {\n\tschema.spaceVector.description = `Where in the phase space the starts, this should be an array of 6 values where empty spaces become a random number between -1000 and 1000`;\n\tschema.octaves.description = `How fine grained the motion is`;\n\tschema.positionVariance.description = `How much it should be moved by`;\n\tschema.rotationVariance.description = `How much it should rotate by`;\n\tschema.speed.description = `Speed multiplier`;\n\tschema.rotationFollowsAxis.description = `If the object should follow the path along certain axis, set it here`;\n}());\n\nconst v2 = new THREE.Vector2();\nconst np = new THREE.Vector3();\nconst temp = new THREE.Vector3();\nconst temp2 = new THREE.Vector3();\nconst nr = new THREE.Vector3();\nconst nre = new THREE.Euler(0,0,0,'ZXY');\nconst nrq = new THREE.Quaternion();\nconst emptyOffset = [0,0,0,0,0,0];\nconst _scale = new THREE.Vector3(1,1,1);\nconst _matrix = new THREE.Matrix4();\n\nconst brownianMotion = {\n\tschema,\n\tdescription: `This component animates an object`,\n\tinit() {\n\t\tthis.initialPosition = new THREE.Vector3().copy(this.el.object3D.position);\n\t\tthis.initialQuaternion = new THREE.Quaternion().copy(this.el.object3D.quaternion);\n\t\tthis.positionOffset = new THREE.Vector3();\n\t\tthis.rotationOffset = new THREE.Vector3();\n\t},\n\tupdate() {\n\t\tthis.positionOffset.x = (this.data.spaceVector[0] === '' || this.data.spaceVector[0] === undefined) ? Math.random()*2000 - 1000 : Number.parseFloat(this.data.spaceVector[0]);\n\t\tthis.positionOffset.y = (this.data.spaceVector[1] === '' || this.data.spaceVector[1] === undefined) ? Math.random()*2000 - 1000 : Number.parseFloat(this.data.spaceVector[1]);\n\t\tthis.positionOffset.z = (this.data.spaceVector[2] === '' || this.data.spaceVector[2] === undefined) ? Math.random()*2000 - 1000 : Number.parseFloat(this.data.spaceVector[2]);\n\t\tthis.rotationOffset.x = (this.data.spaceVector[3] === '' || this.data.spaceVector[3] === undefined) ? Math.random()*2000 - 1000 : Number.parseFloat(this.data.spaceVector[3]);\n\t\tthis.rotationOffset.y = (this.data.spaceVector[4] === '' || this.data.spaceVector[4] === undefined) ? Math.random()*2000 - 1000 : Number.parseFloat(this.data.spaceVector[4]);\n\t\tthis.rotationOffset.z = (this.data.spaceVector[5] === '' || this.data.spaceVector[5] === undefined) ? Math.random()*2000 - 1000 : Number.parseFloat(this.data.spaceVector[5]);\n\t\t\n\t\tthis.rotationFollowsAxis = this.data.rotationFollowsAxis;\n\t\tthis.rotationFollowsAxisMultiplier = 1;\n\t\tif (this.rotationFollowsAxis[0] === '-') {\n\t\t\tthis.rotationFollowsAxis = this.rotationFollowsAxis.substr(1);\n\t\t\tthis.rotationFollowsAxisMultiplier = -1;\n\t\t}\n\t},\n\tseed(number) {\n\t\tseed(number);\n\t},\n\tfbm(x, y, octave) {\n\t\tlet p = v2.set(x,y);\n\t\tlet f = 0.0;\n\t\tlet w = 0.5;\n\t\tfor (let i = 0; i < octave; i++) {\n\t\t\tf += w * perlin2(p.x, p.y);\n\t\t\tp.multiplyScalar(2.0);\n\t\t\tw *= 0.5;\n\t\t}\n\t\treturn f;\n\t},\n\tupdateNPNRQ(time, extraOffset, extraOffsetMultiplier, oldTime) {\n\t\tnp.set(\n\t\t\tthis.fbm(this.positionOffset.x + extraOffset[0] * extraOffsetMultiplier, this.data.speed * time/1000, this.data.octaves),\n\t\t\tthis.fbm(this.positionOffset.y + extraOffset[1] * extraOffsetMultiplier, this.data.speed * time/1000, this.data.octaves),\n\t\t\tthis.fbm(this.positionOffset.z + extraOffset[2] * extraOffsetMultiplier, this.data.speed * time/1000, this.data.octaves)\n\t\t);\n\n\t\tif (this.data.rotationFollowsAxis === 'none') {\n\t\t\tnr.set(\n\t\t\t\tthis.fbm(this.rotationOffset.x + extraOffset[3] * extraOffsetMultiplier, this.data.speed * time/1000, this.data.octaves),\n\t\t\t\tthis.fbm(this.rotationOffset.y + extraOffset[4] * extraOffsetMultiplier, this.data.speed * time/1000, this.data.octaves),\n\t\t\t\tthis.fbm(this.rotationOffset.z + extraOffset[5] * extraOffsetMultiplier, this.data.speed * time/1000, this.data.octaves)\n\t\t\t);\n\t\t\tnr.multiply(this.data.rotationVariance).multiplyScalar(1 / 0.75);\n\t\t\tnre.setFromVector3(nr);\n\t\t\tnrq.setFromEuler(nre);\n\t\t} else {\n\t\t\ttemp2.set(\n\t\t\t\tthis.fbm(this.positionOffset.x + extraOffset[0] * extraOffsetMultiplier, this.data.speed * oldTime/1000, this.data.octaves),\n\t\t\t\tthis.fbm(this.positionOffset.y + extraOffset[1] * extraOffsetMultiplier, this.data.speed * oldTime/1000, this.data.octaves),\n\t\t\t\tthis.fbm(this.positionOffset.z + extraOffset[2] * extraOffsetMultiplier, this.data.speed * oldTime/1000, this.data.octaves)\n\t\t\t);\n\t\t\ttemp2.subVectors(np, temp2).normalize();\n\t\t\ttemp.set(0,0,0);\n\t\t\ttemp[this.rotationFollowsAxis] = 1 * this.rotationFollowsAxisMultiplier;\n\t\t\tnrq.setFromUnitVectors(temp, temp2);\n\t\t}\n\t\tnp.multiply(this.data.positionVariance).multiplyScalar(1 / 0.75);\n\t},\n\ttick(time) {\n\t\tif (!this.startTime) {\n\t\t\tthis.startTime = time;\n\t\t\tthis.oldTime = -16;\n\t\t}\n\t\t\n\t\tthis.updateNPNRQ(time-this.startTime, emptyOffset, 0, this.oldTime);\n\t\tthis.oldTime = time-this.startTime;\n\n\t\tconst object3D = this.el.object3D;\n\t\tobject3D.position.copy(this.initialPosition).add(np);\n\t\tobject3D.quaternion.copy(this.initialQuaternion).multiply(nrq);\n\t}\n};\n\nconst brownianPath = Object.assign({\n\tupdateInstances() {\n\t\tconst data = this.data;\n\t\tconst instances = this.instances;\n\t\tconst instanceGroup = new THREE.Group();\n\t\tif (this.el.getObject3D('instances')) {\n\t\t\tthis.el.removeObject3D('instances');\n\t\t}\n\t\tinstances.splice(0);\n\t\tif (data.object) {\n\t\t\tdata.object.object3D.traverse(function (object) {\n\t\t\t\tif (object.geometry && object.material) {\n\t\t\t\t\tconst instance = new THREE.InstancedMesh(object.geometry, object.material, data.count);\n\t\t\t\t\tinstance.instanceMatrix.setUsage( THREE.DynamicDrawUsage );\n\t\t\t\t\tinstances.push(instance);\n\t\t\t\t\tinstanceGroup.add(instance);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tthis.el.setObject3D('instances', instanceGroup);\n\t}\n}, brownianMotion);\nbrownianPath.schema = Object.assign({\n\tobject: {\n\t\ttype: 'selector',\n\t\tdescription: `Which object to instance with brownian-motion`\n\t},\n\tshowLine: {\n\t\tdefault: false,\n\t\tdescription: `Whether to draw lines`\n\t},\n\tlineColor1: {\n\t\ttype: 'color',\n\t\tdefault: 'orange',\n\t\tdescription: `Color of the first line`\n\t},\n\tlineColor2: {\n\t\ttype: 'color',\n\t\tdefault: 'hotpink',\n\t\tdescription: `Color of the last line`\n\t},\n\tlineStart: {\n\t\tdefault: 0,\n\t\tdescription: `Time stamp to start drawing the lines at`\n\t},\n\tlineStep: {\n\t\tdefault: 20,\n\t\tdescription: `Steps to take in drawing the path`\n\t},\n\tlineEnd: {\n\t\tdefault: 10000,\n\t\tdescription: `Time stamp to stop drawing the lines at`\n\t},\n\tspaceVectorOffset: {\n\t\ttype: 'array',\n\t\tdescription: `Space vector offset for each instance/line`\n\t},\n\tcount: {\n\t\tdefault: 10,\n\t\tdescription: `Number of lines or instances`\n\t}\n}, brownianMotion.schema);\n\nbrownianPath.init = function tick() {\n\tbrownianMotion.init.call(this);\n\tthis.instances = [];\n\tthis.updateInstances = this.updateInstances.bind(this);\n};\n\nbrownianPath.update = function update(oldData) {\n\tconst data = this.data;\n\tbrownianMotion.update.call(this);\n\tthis.spaceVectorOffset = [];\n\tfor (let i=0;i<6;i++) {\n\t\tthis.spaceVectorOffset[i] = data.spaceVectorOffset[i] ? Number(data.spaceVectorOffset[i]) : 0;\n\t}\n\n\t// Redraw the lines\n\tif (this.el.getObject3D('brownianPathLines')) {\n\t\tthis.el.removeObject3D('brownianPathLines');\n\t}\n\tif (data.showLine) {\n\t\tconst c1 = new THREE.Color(data.lineColor1);\n\t\tconst c2 = new THREE.Color(data.lineColor2);\n\t\tconst lineGroup = new THREE.Group();\n\t\tthis.el.setObject3D('brownianPathLines', lineGroup);\n\t\tconst points = [];\n\t\tfor (let i=0;i<data.count;i++) {\n\t\t\tpoints[i] = [];\n\t\t}\n\t\tfor (let t=data.lineStart;t<data.lineEnd;t+=data.lineStep) {\n\t\t\tfor (let i=0;i<data.count;i++) {\n\t\t\t\tthis.updateNPNRQ(t, this.spaceVectorOffset, i);\n\t\t\t\tpoints[i].push( np.clone() );\n\t\t\t}\n\t\t}\n\t\tfor (let i=0;i<data.count;i++) {\n\t\t\tconst material = new THREE.LineBasicMaterial( { color: c1.lerpHSL(c2, i/(this.data.count - 1)) } );\n\t\t\tconst geometry = new THREE.BufferGeometry().setFromPoints( points[i] );\n\t\t\tconst line = new THREE.Line( geometry, material );\n\t\t\tlineGroup.add(line);\n\t\t}\n\t}\n\n\tif (oldData.object) {\n\t\toldData.object.removeEventListener('object3dset', this.updateInstances);\n\t}\n\tif (data.object) {\n\t\tdata.object.addEventListener('object3dset', this.updateInstances);\n\t\tthis.updateInstances();\n\t}\n};\nbrownianPath.tick = function tick(time) {\n\tif (!this.startTime) {\n\t\tthis.startTime = time;\n\t\tthis.oldTime = -16;\n\t}\n\tfor (let i=0;i<this.data.count;i++) {\n\t\tthis.updateNPNRQ(time-this.startTime, this.spaceVectorOffset, i, this.oldTime);\n\t\t_matrix.compose(np, nrq, _scale);\n\t\tfor (const ins of this.instances) {\n\t\t\tins.setMatrixAt( i, _matrix );\n\t\t}\n\t}\n\tthis.oldTime = time-this.startTime;\n\tfor (const ins of this.instances) {\n\t\tins.instanceMatrix.needsUpdate = true;\n\t}\n};\n\nAFRAME.registerComponent('brownian-motion', brownianMotion);\nAFRAME.registerComponent('brownian-path', brownianPath);\n\n\n"],"names":["Grad","constructor","x","y","z","this","dot2","dot3","grad3","p","Uint8Array","perm","Uint16Array","gradP","Array","seed","Math","floor","i","v","fade","t","lerp","a","b","perlin2","X","Y","n00","n01","n10","n11","u","schema","spaceVector","type","octaves","default","positionVariance","THREE","Vector3","rotationVariance","speed","rotationFollowsAxis","oneOf","v2","Vector2","np","temp","temp2","nr","nre","Euler","nrq","Quaternion","emptyOffset","_scale","_matrix","Matrix4","brownianMotion","description","init","initialPosition","copy","el","object3D","position","initialQuaternion","quaternion","positionOffset","rotationOffset","update","data","undefined","random","Number","parseFloat","rotationFollowsAxisMultiplier","substr","number","fbm","octave","set","f","w","multiplyScalar","updateNPNRQ","time","extraOffset","extraOffsetMultiplier","oldTime","multiply","setFromVector3","setFromEuler","subVectors","normalize","setFromUnitVectors","tick","startTime","add","brownianPath","Object","assign","updateInstances","instances","instanceGroup","Group","getObject3D","removeObject3D","splice","object","traverse","geometry","material","instance","InstancedMesh","count","instanceMatrix","setUsage","DynamicDrawUsage","push","setObject3D","showLine","lineColor1","lineColor2","lineStart","lineStep","lineEnd","spaceVectorOffset","call","bind","oldData","c1","Color","c2","lineGroup","points","clone","LineBasicMaterial","color","lerpHSL","BufferGeometry","setFromPoints","line","Line","removeEventListener","addEventListener","compose","ins","setMatrixAt","needsUpdate","AFRAME","registerComponent"],"mappings":"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"}