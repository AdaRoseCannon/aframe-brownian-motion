{"version":3,"file":"aframe-brownian-motion.min.js","sources":["../src/noise.js","../src/aframe-brownian-motion.js"],"sourcesContent":["/* jshint esversion: 9, varstmt:true */\n/*\n * A speed-improved perlin and simplex noise algorithms for 2D.\n *\n * Based on example code by Stefan Gustavson (stegu@itn.liu.se).\n * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\n * Better rank ordering method by Stefan Gustavson in 2012.\n * Converted to Javascript by Joseph Gentle.\n *\n * Version 2012-03-09\n * \n * Modified by AdaRoseCannon 2022-14-07 for AFrame\n *\n * This code was placed in the public domain by its original author,\n * Stefan Gustavson. You may use it as you see fit, but\n * attribution is appreciated.\n *\n */\n\nclass Grad {\n\tconstructor(x, y, z) {\n\t\tthis.x = x; this.y = y; this.z = z;\n\t}\n\tdot2(x, y) {\n\t\treturn this.x * x + this.y * y;\n\t}\n\tdot3(x, y, z) {\n\t\treturn this.x * x + this.y * y + this.z * z;\n\t}\n}\n\nconst grad3 = [new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0),\nnew Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1),\nnew Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1)];\n\nconst p = new Uint8Array([151, 160, 137, 91, 90, 15,\n\t131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,\n\t190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,\n\t88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,\n\t77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,\n\t102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,\n\t135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,\n\t5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,\n\t223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,\n\t129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,\n\t251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,\n\t49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\n\t138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180]);\n// To remove the need for index wrapping, double the permutation table length\nconst perm = new Uint16Array(512);\nconst gradP = Array(512);\n\n// This isn't a very good seeding function, but it works ok. It supports 2^16\n// different seed values. Write something better if you need more seeds.\nexport function seed (seed) {\n\tif (seed > 0 && seed < 1) {\n\t\t// Scale the seed out\n\t\tseed *= 65536;\n\t}\n\n\tseed = Math.floor(seed);\n\tif (seed < 256) {\n\t\tseed |= seed << 8;\n\t}\n\n\tfor (let i = 0; i < 256; i++) {\n\t\tlet v;\n\t\tif (i & 1) {\n\t\t\tv = p[i] ^ (seed & 255);\n\t\t} else {\n\t\t\tv = p[i] ^ ((seed >> 8) & 255);\n\t\t}\n\n\t\tperm[i] = perm[i + 256] = v;\n\t\tgradP[i] = gradP[i + 256] = grad3[v % 12];\n\t}\n}\n\nseed(0);\n\n/*\nfor(const i=0; i<256; i++) {\n\tperm[i] = perm[i + 256] = p[i];\n\tgradP[i] = gradP[i + 256] = grad3[perm[i] % 12];\n}*/\n\n// Skewing and unskewing factors for 2, 3, and 4 dimensions\nconst F2 = 0.5 * (Math.sqrt(3) - 1);\nconst G2 = (3 - Math.sqrt(3)) / 6;\n\nconst F3 = 1 / 3;\nconst G3 = 1 / 6;\n\n// 2D simplex noise\nexport function simplex2 (xin, yin) {\n\tlet n0, n1, n2; // Noise contributions from the three corners\n\t// Skew the input space to determine which simplex cell we're in\n\tconst s = (xin + yin) * F2; // Hairy factor for 2D\n\tlet i = Math.floor(xin + s);\n\tlet j = Math.floor(yin + s);\n\tconst t = (i + j) * G2;\n\tconst x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n\tconst y0 = yin - j + t;\n\t// For the 2D case, the simplex shape is an equilateral triangle.\n\t// Determine which simplex we are in.\n\tlet i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\tif (x0 > y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n\t\ti1 = 1; j1 = 0;\n\t} else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n\t\ti1 = 0; j1 = 1;\n\t}\n\t// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n\t// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n\t// c = (3-sqrt(3))/6\n\tconst x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\tconst y1 = y0 - j1 + G2;\n\tconst x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\n\tconst y2 = y0 - 1 + 2 * G2;\n\t// Work out the hashed gradient indices of the three simplex corners\n\ti &= 255;\n\tj &= 255;\n\tconst gi0 = gradP[i + perm[j]];\n\tconst gi1 = gradP[i + i1 + perm[j + j1]];\n\tconst gi2 = gradP[i + 1 + perm[j + 1]];\n\t// Calculate the contribution from the three corners\n\tlet t0 = 0.5 - x0 * x0 - y0 * y0;\n\tif (t0 < 0) {\n\t\tn0 = 0;\n\t} else {\n\t\tt0 *= t0;\n\t\tn0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient\n\t}\n\tlet t1 = 0.5 - x1 * x1 - y1 * y1;\n\tif (t1 < 0) {\n\t\tn1 = 0;\n\t} else {\n\t\tt1 *= t1;\n\t\tn1 = t1 * t1 * gi1.dot2(x1, y1);\n\t}\n\tlet t2 = 0.5 - x2 * x2 - y2 * y2;\n\tif (t2 < 0) {\n\t\tn2 = 0;\n\t} else {\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * gi2.dot2(x2, y2);\n\t}\n\t// Add contributions from each corner to get the final noise value.\n\t// The result is scaled to return values in the interval [-1,1].\n\treturn 70 * (n0 + n1 + n2);\n}\n\n// 3D simplex noise\nexport function simplex3 (xin, yin, zin) {\n\tlet n0, n1, n2, n3; // Noise contributions from the four corners\n\n\t// Skew the input space to determine which simplex cell we're in\n\tconst s = (xin + yin + zin) * F3; // Hairy factor for 2D\n\tlet i = Math.floor(xin + s);\n\tlet j = Math.floor(yin + s);\n\tlet k = Math.floor(zin + s);\n\n\tconst t = (i + j + k) * G3;\n\tconst x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n\tconst y0 = yin - j + t;\n\tconst z0 = zin - k + t;\n\n\t// For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n\t// Determine which simplex we are in.\n\tlet i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n\tlet i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n\tif (x0 >= y0) {\n\t\tif (y0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }\n\t\telse if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; }\n\t\telse { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; }\n\t} else {\n\t\tif (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; }\n\t\telse if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; }\n\t\telse { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }\n\t}\n\t// A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n\t// a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n\t// a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n\t// c = 1/6.\n\tconst x1 = x0 - i1 + G3; // Offsets for second corner\n\tconst y1 = y0 - j1 + G3;\n\tconst z1 = z0 - k1 + G3;\n\n\tconst x2 = x0 - i2 + 2 * G3; // Offsets for third corner\n\tconst y2 = y0 - j2 + 2 * G3;\n\tconst z2 = z0 - k2 + 2 * G3;\n\n\tconst x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner\n\tconst y3 = y0 - 1 + 3 * G3;\n\tconst z3 = z0 - 1 + 3 * G3;\n\n\t// Work out the hashed gradient indices of the four simplex corners\n\ti &= 255;\n\tj &= 255;\n\tk &= 255;\n\tconst gi0 = gradP[i + perm[j + perm[k]]];\n\tconst gi1 = gradP[i + i1 + perm[j + j1 + perm[k + k1]]];\n\tconst gi2 = gradP[i + i2 + perm[j + j2 + perm[k + k2]]];\n\tconst gi3 = gradP[i + 1 + perm[j + 1 + perm[k + 1]]];\n\n\t// Calculate the contribution from the four corners\n\tlet t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\n\tif (t0 < 0) {\n\t\tn0 = 0;\n\t} else {\n\t\tt0 *= t0;\n\t\tn0 = t0 * t0 * gi0.dot3(x0, y0, z0);  // (x,y) of grad3 used for 2D gradient\n\t}\n\tlet t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\n\tif (t1 < 0) {\n\t\tn1 = 0;\n\t} else {\n\t\tt1 *= t1;\n\t\tn1 = t1 * t1 * gi1.dot3(x1, y1, z1);\n\t}\n\tlet t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\n\tif (t2 < 0) {\n\t\tn2 = 0;\n\t} else {\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * gi2.dot3(x2, y2, z2);\n\t}\n\tlet t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\n\tif (t3 < 0) {\n\t\tn3 = 0;\n\t} else {\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * gi3.dot3(x3, y3, z3);\n\t}\n\t// Add contributions from each corner to get the final noise value.\n\t// The result is scaled to return values in the interval [-1,1].\n\treturn 32 * (n0 + n1 + n2 + n3);\n\n}\n\n// ##### Perlin noise stuff\n\nfunction fade(t) {\n\treturn t * t * t * (t * (t * 6 - 15) + 10);\n}\n\nfunction lerp(a, b, t) {\n\treturn (1 - t) * a + t * b;\n}\n\n// 2D Perlin Noise\nexport function perlin2 (x, y) {\n\t// Find unit grid cell containing point\n\tlet X = Math.floor(x), Y = Math.floor(y);\n\t// Get relative xy coordinates of point within that cell\n\tx = x - X; y = y - Y;\n\t// Wrap the integer cells at 255 (smaller integer period can be introduced here)\n\tX = X & 255; Y = Y & 255;\n\n\t// Calculate noise contributions from each of the four corners\n\tconst n00 = gradP[X + perm[Y]].dot2(x, y);\n\tconst n01 = gradP[X + perm[Y + 1]].dot2(x, y - 1);\n\tconst n10 = gradP[X + 1 + perm[Y]].dot2(x - 1, y);\n\tconst n11 = gradP[X + 1 + perm[Y + 1]].dot2(x - 1, y - 1);\n\n\t// Compute the fade curve value for x\n\tconst u = fade(x);\n\n\t// Interpolate the four results\n\treturn lerp(\n\t\tlerp(n00, n10, u),\n\t\tlerp(n01, n11, u),\n\t\tfade(y));\n}\n\n// 3D Perlin Noise\nexport function perlin3 (x, y, z) {\n\t// Find unit grid cell containing point\n\tlet X = Math.floor(x), Y = Math.floor(y), Z = Math.floor(z);\n\t// Get relative xyz coordinates of point within that cell\n\tx = x - X; y = y - Y; z = z - Z;\n\t// Wrap the integer cells at 255 (smaller integer period can be introduced here)\n\tX = X & 255; Y = Y & 255; Z = Z & 255;\n\n\t// Calculate noise contributions from each of the eight corners\n\tconst n000 = gradP[X + perm[Y + perm[Z]]].dot3(x, y, z);\n\tconst n001 = gradP[X + perm[Y + perm[Z + 1]]].dot3(x, y, z - 1);\n\tconst n010 = gradP[X + perm[Y + 1 + perm[Z]]].dot3(x, y - 1, z);\n\tconst n011 = gradP[X + perm[Y + 1 + perm[Z + 1]]].dot3(x, y - 1, z - 1);\n\tconst n100 = gradP[X + 1 + perm[Y + perm[Z]]].dot3(x - 1, y, z);\n\tconst n101 = gradP[X + 1 + perm[Y + perm[Z + 1]]].dot3(x - 1, y, z - 1);\n\tconst n110 = gradP[X + 1 + perm[Y + 1 + perm[Z]]].dot3(x - 1, y - 1, z);\n\tconst n111 = gradP[X + 1 + perm[Y + 1 + perm[Z + 1]]].dot3(x - 1, y - 1, z - 1);\n\n\t// Compute the fade curve value for x, y, z\n\tconst u = fade(x);\n\tconst v = fade(y);\n\tconst w = fade(z);\n\n\t// Interpolate\n\treturn lerp(\n\t\tlerp(\n\t\t\tlerp(n000, n100, u),\n\t\t\tlerp(n001, n101, u), w),\n\t\tlerp(\n\t\t\tlerp(n010, n110, u),\n\t\t\tlerp(n011, n111, u), w),\n\t\tv);\n}\n","/* jshint esversion: 9, -W028 */\n/* For dealing with covering one object in another curves */\n/* global THREE, AFRAME */\n\nimport {perlin2, seed} from './noise.js';\n\nconst schema = {\n\tspaceVector: {\n\t\ttype: 'array'\n\t},\n\toctaves: {\n\t\tdefault: 2\n\t},\n\tpositionVariance: {\n\t\ttype: 'vec3',\n\t\tdefault: new THREE.Vector3(1,1,1)\n\t},\n\trotationVariance: {\n\t\ttype: 'vec3',\n\t\tdefault: new THREE.Vector3(10,10,10)\n\t},\n\tspeed: {\n\t\tdefault: 1\n\t}\n};\n\ndocumentation:\n(function () {\n\tschema.spaceVector.description = `Where in the phase space the starts, this should be an array of 6 values where empty spaces become a random number between -1000 and 1000`;\n\tschema.octaves.description = `How fine grained the motion is`;\n\tschema.positionVariance.description = `How much it should be moved by`;\n\tschema.rotationVariance.description = `How much it should rotate by`;\n\tschema.speed.description = `Speed multiplier`;\n}());\n\nconst v2 = new THREE.Vector2();\nconst np = new THREE.Vector3();\nconst nr = new THREE.Vector3();\nconst nre = new THREE.Euler(0,0,0,'ZXY');\nconst nrq = new THREE.Quaternion();\nconst emptyOffset = [0,0,0,0,0,0];\nconst _scale = new THREE.Vector3(1,1,1);\nconst _matrix = new THREE.Matrix4();\n\nconst brownianMotion = {\n\tschema,\n\tdescription: `This component animates an object`,\n\tinit() {\n\t\tthis.initialPosition = new THREE.Vector3().copy(this.el.object3D.position);\n\t\tthis.initialQuaternion = new THREE.Quaternion().copy(this.el.object3D.quaternion);\n\t\tthis.positionOffset = new THREE.Vector3();\n\t\tthis.rotationOffset = new THREE.Vector3();\n\t},\n\tupdate() {\n\t\tthis.positionOffset.x = (this.data.spaceVector[0] === '' || this.data.spaceVector[0] === undefined) ? Math.random()*2000 - 1000 : Number.parseFloat(this.data.spaceVector[0]);\n\t\tthis.positionOffset.y = (this.data.spaceVector[1] === '' || this.data.spaceVector[1] === undefined) ? Math.random()*2000 - 1000 : Number.parseFloat(this.data.spaceVector[1]);\n\t\tthis.positionOffset.z = (this.data.spaceVector[2] === '' || this.data.spaceVector[2] === undefined) ? Math.random()*2000 - 1000 : Number.parseFloat(this.data.spaceVector[2]);\n\t\tthis.rotationOffset.x = (this.data.spaceVector[3] === '' || this.data.spaceVector[3] === undefined) ? Math.random()*2000 - 1000 : Number.parseFloat(this.data.spaceVector[3]);\n\t\tthis.rotationOffset.y = (this.data.spaceVector[4] === '' || this.data.spaceVector[4] === undefined) ? Math.random()*2000 - 1000 : Number.parseFloat(this.data.spaceVector[4]);\n\t\tthis.rotationOffset.z = (this.data.spaceVector[5] === '' || this.data.spaceVector[5] === undefined) ? Math.random()*2000 - 1000 : Number.parseFloat(this.data.spaceVector[5]);\n\t},\n\tseed(number) {\n\t\tseed(number);\n\t},\n\tfbm(x, y, octave) {\n\t\tlet p = v2.set(x,y);\n\t\tlet f = 0.0;\n\t\tlet w = 0.5;\n\t\tfor (let i = 0; i < octave; i++) {\n\t\t\tf += w * perlin2(p.x, p.y);\n\t\t\tp.multiplyScalar(2.0);\n\t\t\tw *= 0.5;\n\t\t}\n\t\treturn f;\n\t},\n\tupdateNPNR(time, extraOffset, extraOffsetMultiplier) {\n\t\tnp.set(\n\t\t\tthis.fbm(this.positionOffset.x + extraOffset[0] * extraOffsetMultiplier, this.data.speed * time/1000, this.data.octaves),\n\t\t\tthis.fbm(this.positionOffset.y + extraOffset[1] * extraOffsetMultiplier, this.data.speed * time/1000, this.data.octaves),\n\t\t\tthis.fbm(this.positionOffset.z + extraOffset[2] * extraOffsetMultiplier, this.data.speed * time/1000, this.data.octaves)\n\t\t);\n\n\t\tnr.set(\n\t\t\tthis.fbm(this.rotationOffset.x + extraOffset[3] * extraOffsetMultiplier, this.data.speed * time/1000, this.data.octaves),\n\t\t\tthis.fbm(this.rotationOffset.y + extraOffset[4] * extraOffsetMultiplier, this.data.speed * time/1000, this.data.octaves),\n\t\t\tthis.fbm(this.rotationOffset.z + extraOffset[5] * extraOffsetMultiplier, this.data.speed * time/1000, this.data.octaves)\n\t\t);\n\n\t\tnp.multiply(this.data.positionVariance).multiplyScalar(1 / 0.75);\n\t\tnr.multiply(this.data.rotationVariance).multiplyScalar(1 / 0.75);\n\t},\n\ttick(time) {\n\t\tif (!this.startTime) this.startTime = time;\n\t\tconst object3D = this.el.object3D;\n\n\t\tthis.updateNPNR(time-this.startTime, emptyOffset, 0);\n\n\t\t// transform.localPosition = _initialPosition + np;\n\t\tobject3D.position.copy(this.initialPosition).add(np);\n\t\t// var nrq = quaternion.EulerZXY(math.radians(nr));\n\t\t// transform.localRotation = math.mul(nrq, _initialRotation);\n\t\tnre.setFromVector3(nr);\n\t\tnrq.setFromEuler(nre);\n\t\tobject3D.quaternion.copy(this.initialQuaternion).multiply(nrq);\n\t}\n};\n\nconst brownianPath = Object.assign({\n\tupdateInstances() {\n\t\tconst data = this.data;\n\t\tconst instances = this.instances;\n\t\tconst instanceGroup = new THREE.Group();\n\t\tif (this.el.getObject3D('instances')) {\n\t\t\tthis.el.removeObject3D('instances');\n\t\t}\n\t\tinstances.splice(0);\n\t\tif (data.object) {\n\t\t\tdata.object.object3D.traverse(function (object) {\n\t\t\t\tif (object.geometry && object.material) {\n\t\t\t\t\tconst instance = new THREE.InstancedMesh(object.geometry, object.material, data.count);\n\t\t\t\t\tinstance.instanceMatrix.setUsage( THREE.DynamicDrawUsage );\n\t\t\t\t\tinstances.push(instance);\n\t\t\t\t\tinstanceGroup.add(instance);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tthis.el.setObject3D('instances', instanceGroup);\n\t}\n}, brownianMotion);\nbrownianPath.schema = Object.assign({\n\tobject: {\n\t\ttype: 'selector',\n\t\tdescription: `Which object to instance with brownian-motion`\n\t},\n\tshowLine: {\n\t\tdefault: false,\n\t\tdescription: `Whether to draw lines`\n\t},\n\tlineColor1: {\n\t\ttype: 'color',\n\t\tdefault: 'orange',\n\t\tdescription: `Color of the first line`\n\t},\n\tlineColor2: {\n\t\ttype: 'color',\n\t\tdefault: 'hotpink',\n\t\tdescription: `Color of the last line`\n\t},\n\tlineStart: {\n\t\tdefault: 0,\n\t\tdescription: `Time stamp to start drawing the lines at`\n\t},\n\tlineStep: {\n\t\tdefault: 20,\n\t\tdescription: `Steps to take in drawing the path`\n\t},\n\tlineEnd: {\n\t\tdefault: 10000,\n\t\tdescription: `Time stamp to stop drawing the lines at`\n\t},\n\tspaceVectorOffset: {\n\t\ttype: 'array',\n\t\tdescription: `Space vector offset for each instance/line`\n\t},\n\tcount: {\n\t\tdefault: 10,\n\t\tdescription: `Number of lines or instances`\n\t}\n}, brownianMotion.schema);\n\nbrownianPath.init = function tick() {\n\tbrownianMotion.init.call(this);\n\tthis.instances = [];\n\tthis.updateInstances = this.updateInstances.bind(this);\n};\n\nbrownianPath.update = function update(oldData) {\n\tconst data = this.data;\n\tbrownianMotion.update.call(this);\n\tthis.spaceVectorOffset = [];\n\tfor (let i=0;i<6;i++) {\n\t\tthis.spaceVectorOffset[i] = data.spaceVectorOffset[i] ? Number(data.spaceVectorOffset[i]) : 0;\n\t}\n\n\t// Redraw the lines\n\tif (this.el.getObject3D('brownianPathLines')) {\n\t\tthis.el.removeObject3D('brownianPathLines');\n\t}\n\tif (data.showLine) {\n\t\tconst c1 = new THREE.Color(data.lineColor1);\n\t\tconst c2 = new THREE.Color(data.lineColor2);\n\t\tconst lineGroup = new THREE.Group();\n\t\tthis.el.setObject3D('brownianPathLines', lineGroup);\n\t\tconst points = [];\n\t\tfor (let i=0;i<data.count;i++) {\n\t\t\tpoints[i] = [];\n\t\t}\n\t\tfor (let t=data.lineStart;t<data.lineEnd;t+=data.lineStep) {\n\t\t\tfor (let i=0;i<data.count;i++) {\n\t\t\t\tthis.updateNPNR(t, this.spaceVectorOffset, i);\n\t\t\t\tpoints[i].push( np.clone() );\n\t\t\t}\n\t\t}\n\t\tfor (let i=0;i<data.count;i++) {\n\t\t\tconst material = new THREE.LineBasicMaterial( { color: c1.lerpHSL(c2, i/(this.data.count - 1)) } );\n\t\t\tconst geometry = new THREE.BufferGeometry().setFromPoints( points[i] );\n\t\t\tconst line = new THREE.Line( geometry, material );\n\t\t\tlineGroup.add(line);\n\t\t}\n\t}\n\n\tif (oldData.object) {\n\t\toldData.object.removeEventListener('object3dset', this.updateInstances);\n\t}\n\tif (data.object) {\n\t\tdata.object.addEventListener('object3dset', this.updateInstances);\n\t\tthis.updateInstances();\n\t}\n};\nbrownianPath.tick = function tick(time) {\n\tif (!this.startTime) this.startTime = time;\n\tfor (let i=0;i<this.data.count;i++) {\n\t\tthis.updateNPNR(time-this.startTime, this.spaceVectorOffset, i);\n\t\tnre.setFromVector3(nr);\n\t\tnrq.setFromEuler(nre);\n\t\t_matrix.compose(np, nrq, _scale);\n\t\tfor (const ins of this.instances) {\n\t\t\tins.setMatrixAt( i, _matrix );\n\t\t}\n\t}\n\tfor (const ins of this.instances) {\n\t\tins.instanceMatrix.needsUpdate = true;\n\t}\n};\n\nAFRAME.registerComponent('brownian-motion', brownianMotion);\nAFRAME.registerComponent('brownian-path', brownianPath);\n\n\n"],"names":["Grad","constructor","x","y","z","this","dot2","dot3","grad3","p","Uint8Array","perm","Uint16Array","gradP","Array","seed","Math","floor","i","v","fade","t","lerp","a","b","perlin2","X","Y","n00","n01","n10","n11","u","schema","spaceVector","type","octaves","default","positionVariance","THREE","Vector3","rotationVariance","speed","v2","Vector2","np","nr","nre","Euler","nrq","Quaternion","emptyOffset","_scale","_matrix","Matrix4","brownianMotion","description","init","initialPosition","copy","el","object3D","position","initialQuaternion","quaternion","positionOffset","rotationOffset","update","data","undefined","random","Number","parseFloat","number","fbm","octave","set","f","w","multiplyScalar","updateNPNR","time","extraOffset","extraOffsetMultiplier","multiply","tick","startTime","add","setFromVector3","setFromEuler","brownianPath","Object","assign","updateInstances","instances","instanceGroup","Group","getObject3D","removeObject3D","splice","object","traverse","geometry","material","instance","InstancedMesh","count","instanceMatrix","setUsage","DynamicDrawUsage","push","setObject3D","showLine","lineColor1","lineColor2","lineStart","lineStep","lineEnd","spaceVectorOffset","call","bind","oldData","c1","Color","c2","lineGroup","points","clone","LineBasicMaterial","color","lerpHSL","BufferGeometry","setFromPoints","line","Line","removeEventListener","addEventListener","compose","ins","setMatrixAt","needsUpdate","AFRAME","registerComponent"],"mappings":"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"}